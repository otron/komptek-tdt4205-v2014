
\section{Problem 1, Symbol Tables}
\subsubsection{What is a symbol table, and why is it needed?}
A symbol table is a data structure used by compilers and interpreters that holds the identifiers and relevant information found in the source code of the program.

Variable and function and class names and such are very useful for programmers to tell stuff apart in the code and can also carry some semantic value that aids the programmer in figuring out what the code does.
However computers don't care what a variable is called, as long as it doesn't confuse it with another variable.
Once the symbol table is complete, the identifiers can be replaced with more machine friendly values (e.g. references to an entry in the symbol table).
The symbol table is used in the process of translating variable and function names to addresses and offsets and what not.
You know, whatever the architecture we are compiling for uses.

Also it's useful during error checking.
Type checking (did we try and assign a string to an integer variable?), declaration checking (or whatever, that we don't try and declare more than one thing with the same identifier within the same scope or whatever the language's rules are).


\subsubsection{What kind of information is typically stored in a symbol table?}
Its entries contain identifiers (the `names' of variables, classes and functions) found in the source code and information about them (e.g. their type and address).
Also scopes, if the language supports it.

\subsubsection{Mention and briefly discuss the advantages and disadvantages of three different data structures that can be used to implement symbol tables.}
\paragraph{Linked list}
You know, just a regular linked list or an array or whatever.
The kind where each entry points to the next one and we have to scan the entries sequentially when searching.

Advantages: Easy to implement, O(1) insertion\\
Disadvantages: O(n) lookup, 


\paragraph{Hash table}
Using the identifier as the key.

Advantages: O(1) everything
Disadvantages: 

\paragraph{Binary search tree}
Using the identifier as the key.
This would allow us to find almost matching identifiers when searching through the tree.
However we are typically only interested in knowing if a value is already in the symbol table already or not.

Advantages: O(log n) everything, not very difficult to implement
Disadvantages: 

\newpage
\setcounter{subsubsection}{0}
\section{Problem 2, Symbol tables and blocks}
Consider the following code in a version of [VSL] that includes the keyword \texttt{BLOCK} to start a new scope:
\begin{figure}[H]
\begin{verbatim}
VOID FUNC main() START
    int a;
    FLOAT b;
    ...
    BLOCK
        bool b;
        ... // Position 1
    END

    BLOCK
        int b;
        FLOAT c;
        ...
        BLOCK
            BOOL a;
            INT c;
            ... // Position 2
        END
    END
END
\end{verbatim}
\end{figure}

\subsubsection{Show the contents of the symbol tables at position 1 and 2 assuming an implementation using a stack of symbol tables.}

\subsubsection{Show the cnotent of the symbol tables at position 1 and 2 assuming an implementation using a single symbol table.}

\subsubsection{What are the advantages and disadvantages of these approaches?}

\newpage
\setcounter{subsubsection}{0}
\section{Problem 3, Type checking}
\subsubsection{What is the difference between type synthesis and type inference?}

\subsubsection{Some languages, e.g. FORTRAN, have native support for complex numbers. Draw the widening conversions/hierarchy for the following set of types: \texttt{int}, \texttt{float}, \texttt{double}, \texttt{complex int}, \texttt{complex float}, \texttt{complex double}. State the assumptions you make.}


\newpage
\setcounter{subsubsection}{0}
\section{Problem 4, Types, SDDs}
Consider the following partially completed SDD for type expressions:
\begin{table}[H]
\begin{tabular}{ll}
	\textsc{Production} & \textsc{Semantic Rule} \\ \hline
	T ::= \textbf{int}	&						\\
	T ::= \textbf{float}& \\
	T ::= \textbf{bool} & \\
	T ::= \textbf{T[num]}& \\
	T ::= (L) 			& \\
	L ::= L,T			& \\
	L ::= T				& \\
\end{tabular}
\end{table}

Possible types are the basic types \textbf{int}, \textbf{float}, and \textbf{bool}, arrays of any kind of type, e.g. \textbf{int}[5] or \textbf{float}[5][4] and records (which are collections of one or more types, e.g. \textbf{int}, \textbf{float}, (\textbf{int, bool}[3])).

The purpose of the SDD is to compute the number of bytes that must be allocated to store a value of a given type.
\begin{itemize}
	\item \textbf{int} requires 4 bytes, \textbf{float} requires 8 bytes, \textbf{bool} requires 1 byte.
	\item An array requires the number of bytes a single element, multiplied by the length of the array. For instance, \textbf{int}[5] would require 20 bytes. Similarily, \textbf{int}[5][5] (where the type of the elements is \textbf{int}[5]) would require 100 bytes.
	\item A record requires the sum of bytes required by its members. That is, (\textbf{int, bool}[5]) would require 9 bytes.
\end{itemize}

\subsubsection{Complete the SDD, so that the \textit{size} attribute of T stores the size of the type.}

\subsubsection{Show annotated parse trees for each of these types:}
\begin{description}
	\item[i)] \textbf{int}[4][3][5]
	\item[ii)] (\textbf{int}, \textbf{float}, (\textbf{bool}, \textbf{int}[4]))

\end{description}

\newpage
\section{Problem 5, SDDs}
????
