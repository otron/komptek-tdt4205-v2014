% problem 1
\section{Optimization}
Explain each of the following optimizations and show how they can be used to improve the three-address flow graph.
Start with the original flow graph for each case.

\emph{Note: I use ``Bn.m'' to refer to line m in block n of the original flow graph.}
\subsection{Common subexpression elimination}
% CU lecture 23
% DB pg 588
From \textsc{the Dragon Book}, page 588:
\begin{quote}
``An occurrence of an expression \emph{E} is called a common subexpression if \emph{E} was previously computed and the values of the variables in \emph{E} have not changed since the previous computation.''
\end{quote}

You'd think \textit{B3.6} contains a common subexpression, since \texttt{i + t} is also computed at \textit{B3.2}.
However \textit{B3.2} changes the value of \texttt{i}, so while the expression in \textit{B3.6} was previously computed, the values of the variables have changed and therefore it is not a common subexpression.

\subsection{Copy propagation}
% CU lecture 23
% DB pg 590
``After an assignment, \texttt{x = y}, replace references to \texttt{x} with \texttt{y} until \texttt{x} is assigned something else.''
In this quote, taken from the 23rd CU lecture slides, \texttt{y} probably denotes a variable rather than an expression.

This optimization would change \textit{B3.5} to \texttt{d = i + 2}.

You'd think we should also change \textit{B3.2} to \texttt{i = 1 + t}, because of the assignment in \textit{B1.1}, but doing so would gunk up the code because control can enter \textit{B3} through more than one path ($\mathit{B1} \rightarrow \mathit{B2} \rightarrow \mathit{B3}$ and $\mathit{B3} \rightarrow \mathit{B2} \rightarrow \mathit{B3}$).

\subsection{Code motion}
% DB pg 592
This is when we move the evaluation of a statement that doesn't change over time out of the body of the loop so that it's only computed once rather than once per iteration of the loop.

This optimization would move \textit{B3.1} and \textit{B3.4} to \textit{B1}.

\subsection{Dead code elimination}
% DB pg 591

Dead code elimination is when we remove statements whose effects are never observed in the code.
E.g. if we've got two different assignments to the same variable without the variable ever being referenced in-between the two assignments, then we can remove the first assignment as its effect is never observed.

This would remove \textit{B3.4}. 

% problem 2
\newpage
\section{[More] Optimization}
Consider the following C-code:
\begin{lstlisting}[language=C, tabsize=4, basicstyle=\ttfamily\small]
for (int i =0; i < n; i++) {
	sum = 4 * i;
	for (int j = 0; j < m; j = j + i) {
		a = a + b * 2;
	}
}
\end{lstlisting}

\subsection{In the context of optimization, what is an induction variable, and what is reduction in strength?}
% DB pg 592
\paragraph{Induction variable}
A variable $x$ is said to be an ``induction variable'' if there is a constant $c \in \mathbb{R}$ such that each time $x$ is assigned, its value increases by $c$.

\texttt{i}, as in the textbook example and programmer's favourite loop-counter-variable, is an induction variable.
Who knows how that came to be?
Is it because of those Fortran-people being math-people and mathematicians use $i$ in their sums and matrix indexes?
Does it stand for ``\textbf{i}ndex''?
Oh convention, you are surely the mother of some confusion.

\paragraph{Reduction in strength}
In the context of optimization, it is the replacement of ``expensive'' operations (such as multiplication and division) by a cheaper one (such as addition or subtraction).

\subsection{Convert the code above to a three-address flow graph.}
% I could use flow (http://ctan.mackichan.com/support/flow/flowdoc.pdf) for this
% or I could man up and do it with TikZ, but then I'd have to learn TikZ.
%	http://www.texample.net/tikz/examples/simple-flow-chart/
% Ooorr apparently I could use graphviz. I already sort-of know graphviz, so hmm.
% man, so many choices.
% fuck it let's just use TikZ
%	http://www.texample.net/media/pgf/builds/pgfmanualCVS2012-11-04.pdf
\begin{figure}[H]
\centering
	\input{gfx/2-b.tex}
\label{fig:2-b}
\caption{A three-address flow graph for the code in Problem 2.}
\end{figure}



\subsection{Optimize the flow graph by performing strength reduction on induction variables, and removing unnecessary induction variables.}
% strength reduction on the induction variables
% remove unnecessary induction variables

% sum = 4*i ==> sum = sum + 4
% j is only used for the comparison in block 3
% i is used in the computation of j and in the comparison in block 2
Ok so for the $n$th iteration of the inner loop, the value of \texttt{j} is $j_n$ where $j_n = j_{n-1} + i$ and $j_1 = 0$.
If we work upwards from $j_1$, we see that $j_n = (n-1)*i$.
I'm not sure if it helps, though.
All I managed to do with that was replace \texttt{j = i + j} with \texttt{j = i * n} where \texttt{n} is a new induction variable that increases by 1 for each iteration of the inner loop.
But not only does that introduce a new induction variable, it's also the opposite of strength reduction.
So I didn't do that.

I did do code movement and pulled \texttt{d = b * 2} out of the loop body and also reduced it to \texttt{d = b << 1}.

Also I replaced the multiplication in the assignment of \texttt{sum} with addition.
% d = b << 1
% i also did code motion
